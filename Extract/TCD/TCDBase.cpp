
#include	"stdafx.h"
#include	"../../Image.h"
#include	"../../Ogg.h"
#include	"TCDBase.h"

//////////////////////////////////////////////////////////////////////////////////////////
//	マウント

BOOL	CTCDBase::Mount(
	CArcFile*			pclArc							// アーカイブ
	)
{
	return	FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//	デコード

BOOL	CTCDBase::Decode(
	CArcFile*			pclArc							// アーカイブ
	)
{
	SFileInfo*			pstFileInfo = pclArc->GetOpenFileInfo();

	if( pstFileInfo->format == _T("TCT") )
	{
		return	DecodeTCT( pclArc );
	}

	if( pstFileInfo->format == _T("TSF") )
	{
		return	DecodeTSF( pclArc );
	}

	if( pstFileInfo->format == _T("SPD") )
	{
		return	DecodeSPD( pclArc );
	}

	if( pstFileInfo->format == _T("OGG") )
	{
		return	DecodeOgg( pclArc );
	}

	return	FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//	TCTのデコード

BOOL	CTCDBase::DecodeTCT(
	CArcFile*			pclArc							// アーカイブ
	)
{
	// TSFのデコードルーチンでうまくいく

	return	DecodeTSF( pclArc);
}

//////////////////////////////////////////////////////////////////////////////////////////
//	TSFのデコード

BOOL	CTCDBase::DecodeTSF(
	CArcFile*			pclArc							// アーカイブ
	)
{
	SFileInfo*			pstFileInfo = pclArc->GetOpenFileInfo();

	// 入力バッファ確保

	DWORD				dwSrcSize = pstFileInfo->sizeCmp;

	YCMemory<BYTE>		clmbtSrc( dwSrcSize );

	// 読み込み

	pclArc->Read( &clmbtSrc[0], dwSrcSize );

	// 出力バッファ確保

	DWORD				dwDstSize = *(DWORD*)&clmbtSrc[0];

	YCMemory<BYTE>		clmbtDst( dwDstSize );

	// 解凍

	DecompLZSS( &clmbtDst[0], dwDstSize, &clmbtSrc[4], (dwSrcSize - 4) );

	// 復号

	Decrypt( &clmbtDst[0], dwDstSize );

	// 出力

	pclArc->OpenFile();
	pclArc->WriteFile( &clmbtDst[0], dwDstSize, dwSrcSize );

	return	TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//	SPDのデコード

BOOL	CTCDBase::DecodeSPD(
	CArcFile*			pclArc							// アーカイブ
	)
{
	SFileInfo*			pstFileInfo = pclArc->GetOpenFileInfo();

	// 入力バッファ確保

	DWORD				dwSrcSize = pstFileInfo->sizeCmp;

	YCMemory<BYTE>		clmbtSrc( dwSrcSize );

	// 読み込み

	pclArc->Read( &clmbtSrc[0], dwSrcSize );

	// ヘッダ情報の取得

	DWORD				dwDataSize = *(DWORD*)&clmbtSrc[16];

	long				lWidth = *(long*)&clmbtSrc[8] - ((dwDataSize & 0x04DF) << 2);
	long				lHeight = *(long*)&clmbtSrc[12] - ((dwDataSize >> 2) & 0xF731);
	WORD				wBpp = *(WORD*)&clmbtSrc[6];

	DWORD				dwFlags = *(DWORD*)&clmbtSrc[4] - ((dwDataSize << 4) & 0xFFFF);

	// 出力バッファ確保

	DWORD				dwDstSize = dwDataSize;

	YCMemory<BYTE>		clmbtDst( dwDstSize );

	DWORD				dwDstSize2 = lWidth * lHeight * 4;

	YCMemory<BYTE>		clmbtDst2;

	BYTE*				pbtUnLZSSBuffer = &clmbtSrc[0];
	DWORD				dwUnLZSSBufferSize = dwSrcSize;

	BYTE*				pbtDstForFinal = &clmbtDst[0];
	DWORD				dwDstSizeForFinal = dwDstSize;

	// 解凍

	if( (dwFlags & 0xFF00) == 0 )
	{
		DecompLZSS( &clmbtDst[0], dwDstSize, &clmbtSrc[20], (dwSrcSize - 20) );

		// 次の圧縮を解くためのバッファ確保

		clmbtDst2.resize( dwDstSize2 );

		pbtUnLZSSBuffer = &clmbtDst[0];
		dwUnLZSSBufferSize = dwDstSize;

		pbtDstForFinal = &clmbtDst2[0];
		dwDstSizeForFinal = dwDstSize2;
	}

	switch( dwFlags & 0xFFFF )
	{
	case	0:
		// RLE0

		wBpp = 32;

		DecompRLE0( &pbtDstForFinal[0], dwDstSizeForFinal, &pbtUnLZSSBuffer[0], dwUnLZSSBufferSize );
		break;

	case	1:
		// 無圧縮

		pbtDstForFinal = pbtUnLZSSBuffer;
		dwDstSizeForFinal = dwUnLZSSBufferSize;

		break;

	case	2:
		// RLE2

		wBpp = 32;

		DecompRLE2( &pbtDstForFinal[0], dwDstSizeForFinal, &pbtUnLZSSBuffer[0], dwUnLZSSBufferSize );
		break;

	case	257:
		// 変態的な圧縮

		DecompSPD( &pbtDstForFinal[0], dwDstSizeForFinal, &pbtUnLZSSBuffer[0], dwUnLZSSBufferSize, lWidth );
		break;

	default:
		// 不明

		pclArc->OpenFile();
		pclArc->WriteFile( &clmbtSrc[0], dwSrcSize );

		return	TRUE;
	}

	// 出力

	CImage				clImage;

	clImage.Init( pclArc, lWidth, lHeight, wBpp );
	clImage.WriteReverse( pbtDstForFinal, dwDstSizeForFinal, dwSrcSize );

	return	TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//	Ogg Vorbisのデコード

BOOL	CTCDBase::DecodeOgg(
	CArcFile*			pclArc							// アーカイブ
	)
{
	SFileInfo*			pstFileInfo = pclArc->GetOpenFileInfo();

	// 入力バッファ確保

	DWORD				dwSrcSize = pstFileInfo->sizeCmp;

	YCMemory<BYTE>		clmbtSrc( dwSrcSize );

	// 読み込み

	pclArc->Read( &clmbtSrc[0], dwSrcSize );

	// Ogg VorbisのCRCを修正して出力

	COgg				clOgg;

	clOgg.Decode( pclArc, &clmbtSrc[0] );

	return	TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//	LZSSの解凍

BOOL	CTCDBase::DecompLZSS(
	void*				pvDst,							// 格納先
	DWORD				dwDstSize,						// 格納サイズ
	const void*			pvSrc,							// 入力データ
	DWORD				dwSrcSize						// 入力データサイズ
	)
{
	BYTE*				pbtDst = (BYTE*)pvDst;
	const BYTE*			pbtSrc = (const BYTE*)pvSrc;

	DWORD				dwSrcPtr = 0;
	DWORD				dwDstPtr = 0;

	while( (dwSrcPtr < dwSrcSize) && (dwDstPtr < dwDstSize) )
	{
		BYTE				btFlags = pbtSrc[dwSrcPtr++];

		for( DWORD i = 0 ; (i < 8) && (dwSrcPtr < dwSrcSize) && (dwDstPtr < dwDstSize) ; i++ )
		{
			if( btFlags & 1 )
			{
				// 無圧縮

				pbtDst[dwDstPtr++] = pbtSrc[dwSrcPtr++];
			}
			else
			{
				// 圧縮されている

				WORD				wWork = *(WORD*)&pbtSrc[dwSrcPtr];

				WORD				wLength = (wWork & 0x0F) + 3;
				WORD				wBack = (wWork >> 4);

				DWORD				dwBackPtr = (dwDstPtr - wBack);

				if( (dwDstPtr + wLength) > dwDstSize )
				{
					wLength = dwDstSize - dwDstPtr;
				}

				for( DWORD j = 0 ; j < wLength ; j++ )
				{
					pbtDst[dwDstPtr++] = pbtDst[dwBackPtr++];
				}

				dwSrcPtr += 2;
			}

			btFlags >>= 1;
		}
	}

	return	TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//	RLEの解凍(タイプ0)

BOOL	CTCDBase::DecompRLE0(
	void*				pvDst,							// 格納先
	DWORD				dwDstSize,						// 格納サイズ
	const void*			pvSrc,							// 入力データ
	DWORD				dwSrcSize						// 入力データサイズ
	)
{
	const BYTE*			pbtSrc = (const BYTE*)pvSrc;
	BYTE*				pbtDst = (BYTE*)pvDst;

	DWORD				dwOffset = *(DWORD*)&pbtSrc[0];
	DWORD				dwPixelCount = *(DWORD*)&pbtSrc[4];
	DWORD				dwZeroFlag = *(DWORD*)&pbtSrc[8];

	BOOL				bZero = (dwZeroFlag == 0);

	DWORD				dwSrcHeaderPtr = 12;
	DWORD				dwSrcDataPtr = dwOffset;
	DWORD				dwDstPtr = 0;

	while( (dwSrcHeaderPtr < dwOffset) && (dwSrcDataPtr < dwSrcSize) && (dwDstPtr < dwDstSize) )
	{
		DWORD				dwLength = *(DWORD*)&pbtSrc[dwSrcHeaderPtr];

		dwSrcHeaderPtr += 4;

		if( (dwDstPtr + (dwLength * 4)) > dwDstSize )
		{
			MessageBox( NULL, _T("RLE0の解凍に必要な出力バッファが足りません。多分落ちます。"), _T("エラー"), 0 );
		}

		if( bZero )
		{
			for( DWORD i = 0 ; i < dwLength ; i++ )
			{
				for( DWORD j = 0 ; j < 4 ; j++ )
				{
					pbtDst[dwDstPtr++] = 0x00;
				}
			}
		}
		else
		{
			if( (dwSrcDataPtr + (dwLength * 3)) > dwSrcSize )
			{
				MessageBox( NULL, _T("RLE0の解凍に必要な入力バッファが足りません。多分落ちます。"), _T("エラー"), 0 );
			}

			for( DWORD i = 0 ; i < dwLength ; i++ )
			{
				for( DWORD j = 0 ; j < 3 ; j++ )
				{
					pbtDst[dwDstPtr++] = pbtSrc[dwSrcDataPtr++];
				}

				pbtDst[dwDstPtr++] = 0xFF;
			}
		}

		bZero = !bZero;
	}

	return	TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//	RLEの解凍(タイプ2)

BOOL	CTCDBase::DecompRLE2(
	void*				pvDst,							// 格納先
	DWORD				dwDstSize,						// 格納サイズ
	const void*			pvSrc,							// 入力データ
	DWORD				dwSrcSize						// 入力データサイズ
	)
{
	return	FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//	SPDの解凍

BOOL	CTCDBase::DecompSPD(
	void*				pvDst,							// 格納先
	DWORD				dwDstSize,						// 格納先サイズ
	const void*			pvSrc,							// 入力データ
	DWORD				dwSrcSize,						// 入力データサイズ
	long				lWidth							// 画像の幅
	)
{
	static const BYTE	abtKey1[256] = {
		0x10, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1, 0xF0,
		0x08, 0x08, 0x07, 0x07, 0x06, 0x06, 0x05, 0x05, 0xFB, 0xFB, 0xFA, 0xFA, 0xF9, 0xF9, 0xF8, 0xF8,
		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
		0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
		0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE
	};

	static const BYTE	abtKey2[1024] = {
		0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00
	};

	static const BYTE	abtKey3[128] = {
		0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x0A, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00
	};

	long				alKey4[28];
	long				lWork;

	for( DWORD i = 0 ; i < 16 ; i++ )
	{
		alKey4[i] = -3;
	}

	lWork = ~(lWidth * 3) + 1;

	for( DWORD i = 16 ; i < 24 ; i++ )
	{
		alKey4[i] = lWork;
	}

	for( DWORD i = 24 ; i < 26 ; i++ )
	{
		alKey4[i] = (lWork - 3);
	}

	for( DWORD i = 26 ; i < 28 ; i++ )
	{
		alKey4[i] = (lWork + 3);
	}

	// 解凍

	const BYTE*			pbtSrc = (const BYTE*)pvSrc;
	BYTE*				pbtDst = (BYTE*)pvDst;

	DWORD				dwSrcPtr = 20;
	DWORD				dwDstPtr = 0;
	DWORD				dwOffset = 24;

	for( DWORD i = 0 ; i < 3 ; i++ )
	{
		pbtDst[dwDstPtr++] = pbtSrc[dwSrcPtr + i];
	}

	while( dwDstPtr < dwDstSize )
	{
		DWORD				dwSrcPtrTemp = dwSrcPtr + (dwOffset >> 3);
		DWORD				dwShift = (dwOffset & 7);

		DWORD				dwData = *(DWORD*)&pbtSrc[dwSrcPtrTemp + 0];
		DWORD				dwKeyPtr = *(DWORD*)&pbtSrc[dwSrcPtrTemp + 1];

		_asm
		{
			push	ecx
			push	edx
			push	ebx
			push	esi

			mov		edx, dwData
			mov		esi, dwKeyPtr
			mov		ecx, dwShift
			xor		ebx, ebx

			bswap	edx
			shld	edx, esi, cl
			shld	ebx, edx, 5

			mov		dwData, edx
			mov		dwKeyPtr, ebx

			pop		esi
			pop		ebx
			pop		edx
			pop		ecx
		}

		if( dwKeyPtr > 0x1B )
		{
			dwData >>= 5;

			for( DWORD i = 0 ; i < 3 ; i++ )
			{
				pbtDst[dwDstPtr++] = (BYTE)((dwData >> (i * 8)) & 0xFF);
			}

			dwOffset += 0x1B;
		}
		else
		{
			DWORD				dwBackPtr = dwDstPtr + alKey4[dwKeyPtr];

			for( DWORD i = 0 ; i < 3 ; i++ )
			{
				pbtDst[dwDstPtr + i] = pbtDst[dwBackPtr++];
			}

			dwShift = *(DWORD*)&abtKey3[dwKeyPtr * 4] >> 1;

			dwOffset += dwShift;

			if( *(DWORD*)&abtKey3[dwKeyPtr * 4] & 1 )
			{
				BYTE				btPrevKey1 = 0;

				dwShift += 8;

				_asm
				{
					push	ecx

					mov		ecx, dwShift
					rol		dwData, cl

					pop		ecx
				}

				dwKeyPtr = (dwData & 0xFF);
				dwShift = *(DWORD*)&abtKey2[dwKeyPtr * 4];
				dwOffset += dwShift;

				btPrevKey1 = abtKey1[dwKeyPtr];
				pbtDst[dwDstPtr++] += btPrevKey1;

				_asm
				{
					push	ecx

					mov		ecx, dwShift
					rol		dwData, cl

					pop		ecx
				}

				dwKeyPtr = (dwData & 0xFF);
				dwShift = *(DWORD*)&abtKey2[dwKeyPtr * 4];
				dwOffset += dwShift;

				pbtDst[dwDstPtr++] += btPrevKey1 + abtKey1[dwKeyPtr];

				_asm
				{
					push	ecx

					mov		ecx, dwShift
					rol		dwData, cl

					pop		ecx
				}

				dwKeyPtr = (dwData & 0xFF);
				dwShift = *(DWORD*)&abtKey2[dwKeyPtr * 4];
				dwOffset += dwShift;

				pbtDst[dwDstPtr++] += btPrevKey1 + abtKey1[dwKeyPtr];
			}
			else
			{
				dwDstPtr += 3;
			}
		}
	}

	return	TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//	復号

BOOL	CTCDBase::Decrypt(
	void*				pvData,							// データ
	DWORD				dwDataSize						// データサイズ
	)
{
	BYTE*				pbtData = (BYTE*)pvData;

	for( DWORD i = 0 ; i < dwDataSize ; i++ )
	{
		BYTE				btData = pbtData[i];

		_asm
		{
			ror		btData, 1
		}

		pbtData[i] = btData;
	}

	return	TRUE;
}

#include "StdAfx.h"
#include "Image.h"
#include "Sound/Ogg.h"
#include "Extract/TCD/TCDBase.h"
#include "Utils/BitUtils.h"

bool CTCDBase::Mount(CArcFile* archive)
{
	return false;
}

bool CTCDBase::Decode(CArcFile* archive)
{
	const SFileInfo* file_info = archive->GetOpenFileInfo();

	if (file_info->format == _T("TCT"))
		return DecodeTCT(archive);

	if (file_info->format == _T("TSF"))
		return DecodeTSF(archive);

	if (file_info->format == _T("SPD"))
		return DecodeSPD(archive);

	if (file_info->format == _T("OGG"))
		return DecodeOgg(archive);

	return false;
}

/// Decode TCT
///
/// @param archive Archive
///
bool CTCDBase::DecodeTCT(CArcFile* archive)
{
	// TSF Decoding routine

	return DecodeTSF(archive);
}

/// Decode TSF
///
/// @param archive Archive
///
bool CTCDBase::DecodeTSF(CArcFile* archive)
{
	const SFileInfo* file_info = archive->GetOpenFileInfo();

	// Adjust input buffer
	const DWORD src_size = file_info->sizeCmp;
	YCMemory<BYTE> src(src_size);

	// Read
	archive->Read(&src[0], src_size);

	// Ensure output buffer
	const DWORD dst_size = *(DWORD*)&src[0];
	YCMemory<BYTE> dst(dst_size);

	// Decompress
	DecompLZSS(&dst[0], dst_size, &src[4], (src_size - 4));

	// Decode
	Decrypt(&dst[0], dst_size);

	// Output
	archive->OpenFile();
	archive->WriteFile(&dst[0], dst_size, src_size);

	return true;
}

/// Decode SPD
///
/// @param archive Archive
///
bool CTCDBase::DecodeSPD(CArcFile* archive)
{
	const SFileInfo* file_info = archive->GetOpenFileInfo();

	// Ensure input buffer
	const DWORD src_size = file_info->sizeCmp;
	YCMemory<BYTE> src(src_size);

	// Read
	archive->Read(&src[0], src_size);

	// Get header info
	const DWORD data_size = *(DWORD*)&src[16];

	const long width = *(long*)&src[8] - ((data_size & 0x04DF) << 2);
	const long height = *(long*)&src[12] - ((data_size >> 2) & 0xF731);
	WORD bpp = *(WORD*)&src[6];

	const DWORD flags = *(DWORD*)&src[4] - ((data_size << 4) & 0xFFFF);

	// Ensure output buffer
	const DWORD dst_size = data_size;
	YCMemory<BYTE> dst(dst_size);

	const DWORD dst_size2 = width * height * 4;
	YCMemory<BYTE> dst2;

	BYTE* unlzss_buffer = &src[0];
	DWORD unlzss_buffer_size = src_size;

	BYTE* output_buffer = &dst[0];
	DWORD output_buffer_size = dst_size;

	// Decompression

	if ((flags & 0xFF00) == 0)
	{
		DecompLZSS(&dst[0], dst_size, &src[20], (src_size - 20));

		// Ensure buffer to perform the following decompression

		dst2.resize(dst_size2);

		unlzss_buffer = &dst[0];
		unlzss_buffer_size = dst_size;

		output_buffer = &dst2[0];
		output_buffer_size = dst_size2;
	}

	switch (flags & 0xFFFF)
	{
	case 0: // RLE0
		bpp = 32;
		DecompRLE0(&output_buffer[0], output_buffer_size, &unlzss_buffer[0], unlzss_buffer_size);
		break;

	case 1: // No compression
		output_buffer = unlzss_buffer;
		output_buffer_size = unlzss_buffer_size;
		break;

	case 2: // RLE2
		bpp = 32;
		DecompRLE2(&output_buffer[0], output_buffer_size, &unlzss_buffer[0], unlzss_buffer_size);
		break;

	case 257: // Compression Transformation
		DecompSPD(&output_buffer[0], output_buffer_size, &unlzss_buffer[0], unlzss_buffer_size, width);
		break;

	default: // Unknown
		archive->OpenFile();
		archive->WriteFile(&src[0], src_size);
		return true;
	}

	// Output

	CImage image;
	image.Init(archive, width, height, bpp);
	image.WriteReverse(output_buffer, output_buffer_size, src_size);

	return true;
}

/// Decode Ogg Vorbis
///
/// @param archive Archive
///
bool CTCDBase::DecodeOgg(CArcFile* archive)
{
	const SFileInfo* file_info = archive->GetOpenFileInfo();

	// Ensure input buffer
	const DWORD src_size = file_info->sizeCmp;
	YCMemory<BYTE> src(src_size);

	// Read
	archive->Read(&src[0], src_size);

	// Fix the CRC of Ogg Vorbis on output
	COgg ogg;
	ogg.Decode(archive, &src[0]);

	return true;
}

/// Decompress LZSS
///
/// @param dst       Destination
/// @param dst_size Destination size
/// @param src      Input data
/// @param src_size Input data size
///
bool CTCDBase::DecompLZSS(void* dst, DWORD dst_size, const void* src, DWORD src_size)
{
	BYTE* byte_dst = (BYTE*)dst;
	const BYTE* byte_src = (const BYTE*)src;

	DWORD src_ptr = 0;
	DWORD dst_ptr = 0;

	while (src_ptr < src_size && dst_ptr < dst_size)
	{
		BYTE flags = byte_src[src_ptr++];

		for (DWORD i = 0; (i < 8) && (src_ptr < src_size) && (dst_ptr < dst_size); i++)
		{
			if (flags & 1)
			{
				// No compression

				byte_dst[dst_ptr++] = byte_src[src_ptr++];
			}
			else
			{
				// Is compressed 

				const WORD work = *(WORD*)&byte_src[src_ptr];

				WORD length = (work & 0x0F) + 3;
				const WORD back = work >> 4;

				DWORD back_ptr = dst_ptr - back;

				if (dst_ptr + length > dst_size)
				{
					length = dst_size - dst_ptr;
				}

				for (size_t j = 0; j < length; j++)
				{
					byte_dst[dst_ptr++] = byte_dst[back_ptr++];
				}

				src_ptr += 2;
			}

			flags >>= 1;
		}
	}

	return true;
}

/// Decode RLE (Type 0)
///
/// @param dst      Destination
/// @param dst_size Destination size
/// @param src      Input data
/// @param src_size Input data size
///
bool CTCDBase::DecompRLE0(void* dst, DWORD dst_size, const void* src, DWORD src_size)
{
	const BYTE* byte_src = (const BYTE*)src;
	BYTE* byte_dst = (BYTE*)dst;

	const DWORD offset = *(DWORD*)&byte_src[0];
	const DWORD pixel_count = *(DWORD*)&byte_src[4];
	const DWORD zero_flag = *(DWORD*)&byte_src[8];

	bool is_zero = zero_flag == 0;

	DWORD src_header_ptr = 12;
	DWORD src_data_ptr = offset;
	DWORD dst_ptr = 0;

	while ((src_header_ptr < offset) && (src_data_ptr < src_size) && (dst_ptr < dst_size))
	{
		const DWORD length = *(DWORD*)&byte_src[src_header_ptr];

		src_header_ptr += 4;

		if ((dst_ptr + (length * 4)) > dst_size)
		{
			MessageBox(nullptr, _T("Output buffer needed to decompress RLE0 is too small."), _T("Error"), 0);
		}

		if (is_zero)
		{
			for (DWORD i = 0; i < length; i++)
			{
				for (DWORD j = 0; j < 4; j++)
				{
					byte_dst[dst_ptr++] = 0x00;
				}
			}
		}
		else
		{
			if ((src_data_ptr + (length * 3)) > src_size)
			{
				MessageBox(nullptr, _T("Input buffer needed to decompress RLE0 is too small."), _T("Error"), 0);
			}

			for (DWORD i = 0; i < length; i++)
			{
				for (DWORD j = 0; j < 3; j++)
				{
					byte_dst[dst_ptr++] = byte_src[src_data_ptr++];
				}

				byte_dst[dst_ptr++] = 0xFF;
			}
		}

		is_zero = !is_zero;
	}

	return true;
}

/// Decode RLE (Type 2)
///
/// @param dst      Destination
/// @param dst_size Destination size
/// @param src      Input data
/// @param src_size Input data size
///
bool CTCDBase::DecompRLE2(void* dst, DWORD dst_size, const void* src, DWORD src_size)
{
	return false;
}

/// Decompress SPD
///
/// @param dst      Destination
/// @param dst_size Destination size
/// @param src      Input data
/// @param src_size Input data size
/// @param width    Image width
///
bool CTCDBase::DecompSPD(void* dst, DWORD dst_size, const void* src, DWORD src_size, long width)
{
	static const BYTE key1[256] = {
		0x10, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1, 0xF0,
		0x08, 0x08, 0x07, 0x07, 0x06, 0x06, 0x05, 0x05, 0xFB, 0xFB, 0xFA, 0xFA, 0xF9, 0xF9, 0xF8, 0xF8,
		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
		0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
		0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE
	};

	static const BYTE key2[1024] = {
		0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00
	};

	static const BYTE key3[128] = {
		0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x0A, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00
	};

	long key4[28];

	for (size_t i = 0; i < 16; i++)
	{
		key4[i] = -3;
	}

	const long work = ~(width * 3) + 1;

	for (size_t i = 16; i < 24; i++)
	{
		key4[i] = work;
	}

	for (size_t i = 24; i < 26; i++)
	{
		key4[i] = (work - 3);
	}

	for (size_t i = 26; i < 28; i++)
	{
		key4[i] = (work + 3);
	}

	// Decompress
	const BYTE* byte_src = (const BYTE*)src;
	BYTE* byte_dst = (BYTE*)dst;

	DWORD src_ptr = 20;
	DWORD dst_ptr = 0;
	DWORD offset = 24;

	for (size_t i = 0; i < 3; i++)
	{
		byte_dst[dst_ptr++] = byte_src[src_ptr + i];
	}

	while (dst_ptr < dst_size)
	{
		const DWORD src_ptr_temp = src_ptr + (offset >> 3);
		DWORD shift = (offset & 7);

		DWORD data = *(DWORD*)&byte_src[src_ptr_temp + 0];
		DWORD key_ptr = *(DWORD*)&byte_src[src_ptr_temp + 1];

		data = BitUtils::Swap32(data); 
		data = (data << shift) | (key_ptr >> (32 - shift));
		key_ptr = (data >> 27);

		if (key_ptr > 0x1B)
		{
			data >>= 5;

			for (DWORD i = 0; i < 3; i++)
			{
				byte_dst[dst_ptr++] = (BYTE)((data >> (i * 8)) & 0xFF);
			}

			offset += 0x1B;
		}
		else
		{
			DWORD back_ptr = dst_ptr + key4[key_ptr];

			for (size_t i = 0; i < 3; i++)
			{
				byte_dst[dst_ptr + i] = byte_dst[back_ptr++];
			}

			shift = *(DWORD*)&key3[key_ptr * 4] >> 1;

			offset += shift;

			if (*(DWORD*)&key3[key_ptr * 4] & 1)
			{
				BYTE prev_key1 = 0;

				shift += 8;

				data = BitUtils::RotateLeft(data, shift);

				key_ptr = (data & 0xFF);
				shift = *(DWORD*)&key2[key_ptr * 4];
				offset += shift;

				prev_key1 = key1[key_ptr];
				byte_dst[dst_ptr++] += prev_key1;

				data = BitUtils::RotateLeft(data, shift);

				key_ptr = (data & 0xFF);
				shift = *(DWORD*)&key2[key_ptr * 4];
				offset += shift;

				byte_dst[dst_ptr++] += prev_key1 + key1[key_ptr];

				data = BitUtils::RotateLeft(data, shift);

				key_ptr = (data & 0xFF);
				shift = *(DWORD*)&key2[key_ptr * 4];
				offset += shift;

				byte_dst[dst_ptr++] += prev_key1 + key1[key_ptr];
			}
			else
			{
				dst_ptr += 3;
			}
		}
	}

	return true;
}

/// Decryption
///
/// @param data      Data
/// @param data_size Data size
///
bool CTCDBase::Decrypt(void* data, DWORD data_size)
{
	BYTE* const pbtData = static_cast<BYTE*>(data);

	for (size_t i = 0; i < data_size; i++)
	{
		pbtData[i] = BitUtils::RotateRight(pbtData[i], 1);
	}

	return true;
}

#include "StdAfx.h"
#include "Extract/TCD/TCDBase.h"

#include "ArcFile.h"
#include "Image.h"
#include "Sound/Ogg.h"
#include "Utils/BitUtils.h"

bool CTCDBase::Mount(CArcFile* archive)
{
	return false;
}

bool CTCDBase::Decode(CArcFile* archive)
{
	const SFileInfo* file_info = archive->GetOpenFileInfo();

	if (file_info->format == _T("TCT"))
		return DecodeTCT(archive);

	if (file_info->format == _T("TSF"))
		return DecodeTSF(archive);

	if (file_info->format == _T("SPD"))
		return DecodeSPD(archive);

	if (file_info->format == _T("OGG"))
		return DecodeOgg(archive);

	return false;
}

/// Decode TCT
///
/// @param archive Archive
///
bool CTCDBase::DecodeTCT(CArcFile* archive)
{
	// TSF Decoding routine

	return DecodeTSF(archive);
}

/// Decode TSF
///
/// @param archive Archive
///
bool CTCDBase::DecodeTSF(CArcFile* archive)
{
	const SFileInfo* file_info = archive->GetOpenFileInfo();

	// Adjust input buffer
	std::vector<u8> src(file_info->sizeCmp);

	// Read
	archive->Read(src.data(), src.size());

	// Ensure output buffer
	const u32 dst_size = *reinterpret_cast<u32*>(&src[0]);
	std::vector<u8> dst(dst_size);

	// Decompress
	DecompLZSS(dst.data(), dst.size(), &src[4], src.size() - 4);

	// Decode
	Decrypt(dst.data(), dst.size());

	// Output
	archive->OpenFile();
	archive->WriteFile(dst.data(), dst.size(), src.size());

	return true;
}

/// Decode SPD
///
/// @param archive Archive
///
bool CTCDBase::DecodeSPD(CArcFile* archive)
{
	const SFileInfo* file_info = archive->GetOpenFileInfo();

	// Ensure input buffer
	std::vector<u8> src(file_info->sizeCmp);

	// Read
	archive->Read(src.data(), src.size());

	// Get header info
	const u32 data_size = *reinterpret_cast<u32*>(&src[16]);

	const s32 width = *reinterpret_cast<s32*>(&src[8]) - ((data_size & 0x04DF) << 2);
	const s32 height = *reinterpret_cast<s32*>(&src[12]) - ((data_size >> 2) & 0xF731);
	u16 bpp = *reinterpret_cast<u16*>(&src[6]);

	const u32 flags = *reinterpret_cast<u32*>(&src[4]) - ((data_size << 4) & 0xFFFF);

	// Ensure output buffer
	std::vector<u8> dst(data_size);

	const u32 dst_size2 = static_cast<u32>(width * height * 4);
	std::vector<u8> dst2;

	u8* unlzss_buffer = src.data();
	size_t unlzss_buffer_size = src.size();

	u8* output_buffer = dst.data();
	size_t output_buffer_size = dst.size();

	// Decompression

	if ((flags & 0xFF00) == 0)
	{
		DecompLZSS(dst.data(), dst.size(), &src[20], src.size() - 20);

		// Ensure buffer to perform the following decompression
		dst2.resize(dst_size2);

		unlzss_buffer = dst.data();
		unlzss_buffer_size = dst.size();

		output_buffer = dst2.data();
		output_buffer_size = dst2.size();
	}

	switch (flags & 0xFFFF)
	{
	case 0: // RLE0
		bpp = 32;
		DecompRLE0(&output_buffer[0], output_buffer_size, &unlzss_buffer[0], unlzss_buffer_size);
		break;

	case 1: // No compression
		output_buffer = unlzss_buffer;
		output_buffer_size = unlzss_buffer_size;
		break;

	case 2: // RLE2
		bpp = 32;
		DecompRLE2(&output_buffer[0], output_buffer_size, &unlzss_buffer[0], unlzss_buffer_size);
		break;

	case 257: // Compression Transformation
		DecompSPD(&output_buffer[0], output_buffer_size, &unlzss_buffer[0], unlzss_buffer_size, width);
		break;

	default: // Unknown
		archive->OpenFile();
		archive->WriteFile(src.data(), src.size());
		return true;
	}

	// Output

	CImage image;
	image.Init(archive, width, height, bpp);
	image.WriteReverse(output_buffer, output_buffer_size, src.size() != 0);

	return true;
}

/// Decode Ogg Vorbis
///
/// @param archive Archive
///
bool CTCDBase::DecodeOgg(CArcFile* archive)
{
	const SFileInfo* file_info = archive->GetOpenFileInfo();

	// Ensure input buffer
	std::vector<u8> src(file_info->sizeCmp);

	// Read
	archive->Read(src.data(), src.size());

	// Fix the CRC of Ogg Vorbis on output
	COgg ogg;
	ogg.Decode(archive, src.data());

	return true;
}

/// Decompress LZSS
///
/// @param dst      Destination
/// @param dst_size Destination size
/// @param src      Input data
/// @param src_size Input data size
///
bool CTCDBase::DecompLZSS(u8* dst, size_t dst_size, const u8* src, size_t src_size)
{
	size_t src_ptr = 0;
	size_t dst_ptr = 0;

	while (src_ptr < src_size && dst_ptr < dst_size)
	{
		u8 flags = src[src_ptr++];

		for (size_t i = 0; i < 8 && src_ptr < src_size && dst_ptr < dst_size; i++)
		{
			if (flags & 1)
			{
				// No compression
				dst[dst_ptr++] = src[src_ptr++];
			}
			else
			{
				// Is compressed 
				const u16 work = *reinterpret_cast<const u16*>(&src[src_ptr]);

				size_t length = (work & 0x0F) + 3;
				const u16 back = work >> 4;

				size_t back_ptr = dst_ptr - back;

				if (dst_ptr + length > dst_size)
				{
					length = dst_size - dst_ptr;
				}

				for (size_t j = 0; j < length; j++)
				{
					dst[dst_ptr++] = dst[back_ptr++];
				}

				src_ptr += 2;
			}

			flags >>= 1;
		}
	}

	return true;
}

/// Decode RLE (Type 0)
///
/// @param dst      Destination
/// @param dst_size Destination size
/// @param src      Input data
/// @param src_size Input data size
///
bool CTCDBase::DecompRLE0(u8* dst, size_t dst_size, const u8* src, size_t src_size)
{
	const u32 offset      = *reinterpret_cast<const u32*>(&src[0]);
	const u32 pixel_count = *reinterpret_cast<const u32*>(&src[4]);
	const u32 zero_flag   = *reinterpret_cast<const u32*>(&src[8]);

	bool is_zero = zero_flag == 0;

	size_t src_header_ptr = 12;
	size_t src_data_ptr = offset;
	size_t dst_ptr = 0;

	while (src_header_ptr < offset && src_data_ptr < src_size && dst_ptr < dst_size)
	{
		const u32 length = *reinterpret_cast<const u32*>(&src[src_header_ptr]);

		src_header_ptr += 4;

		if ((dst_ptr + (length * 4)) > dst_size)
		{
			MessageBox(nullptr, _T("Output buffer needed to decompress RLE0 is too small."), _T("Error"), 0);
		}

		if (is_zero)
		{
			for (u32 i = 0; i < length; i++)
			{
				for (u32 j = 0; j < 4; j++)
				{
					dst[dst_ptr++] = 0x00;
				}
			}
		}
		else
		{
			if ((src_data_ptr + (length * 3)) > src_size)
			{
				MessageBox(nullptr, _T("Input buffer needed to decompress RLE0 is too small."), _T("Error"), 0);
			}

			for (u32 i = 0; i < length; i++)
			{
				for (u32 j = 0; j < 3; j++)
				{
					dst[dst_ptr++] = src[src_data_ptr++];
				}

				dst[dst_ptr++] = 0xFF;
			}
		}

		is_zero = !is_zero;
	}

	return true;
}

/// Decode RLE (Type 2)
///
/// @param dst      Destination
/// @param dst_size Destination size
/// @param src      Input data
/// @param src_size Input data size
///
bool CTCDBase::DecompRLE2(u8* dst, size_t dst_size, const u8* src, size_t src_size)
{
	return false;
}

/// Decompress SPD
///
/// @param dst      Destination
/// @param dst_size Destination size
/// @param src      Input data
/// @param src_size Input data size
/// @param width    Image width
///
bool CTCDBase::DecompSPD(u8* dst, size_t dst_size, const u8* src, size_t src_size, s32 width)
{
	static const u8 key1[256] = {
		0x10, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1, 0xF0,
		0x08, 0x08, 0x07, 0x07, 0x06, 0x06, 0x05, 0x05, 0xFB, 0xFB, 0xFA, 0xFA, 0xF9, 0xF9, 0xF8, 0xF8,
		0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
		0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
		0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
		0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
		0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE
	};

	static const u8 key2[1024] = {
		0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
		0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00
	};

	static const u8 key3[128] = {
		0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
		0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
		0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
		0x0A, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00,
		0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00
	};

	s32 key4[28];

	for (size_t i = 0; i < 16; i++)
	{
		key4[i] = -3;
	}

	const s32 work = ~(width * 3) + 1;

	for (size_t i = 16; i < 24; i++)
	{
		key4[i] = work;
	}

	for (size_t i = 24; i < 26; i++)
	{
		key4[i] = (work - 3);
	}

	for (size_t i = 26; i < 28; i++)
	{
		key4[i] = (work + 3);
	}

	// Decompress
	size_t src_ptr = 20;
	size_t dst_ptr = 0;
	size_t offset = 24;

	for (size_t i = 0; i < 3; i++)
	{
		dst[dst_ptr++] = src[src_ptr + i];
	}

	while (dst_ptr < dst_size)
	{
		const size_t src_ptr_temp = src_ptr + (offset >> 3);
		u32 shift = static_cast<u32>(offset & 7);

		u32 data = *reinterpret_cast<const u32*>(&src[src_ptr_temp + 0]);
		u32 key_ptr = *reinterpret_cast<const u32*>(&src[src_ptr_temp + 1]);

		data = BitUtils::Swap32(data); 
		data = (data << shift) | (key_ptr >> (32 - shift));
		key_ptr = data >> 27;

		if (key_ptr > 0x1B)
		{
			data >>= 5;

			for (u32 i = 0; i < 3; i++)
			{
				dst[dst_ptr++] = static_cast<u8>((data >> (i * 8)) & 0xFF);
			}

			offset += 0x1B;
		}
		else
		{
			size_t back_ptr = dst_ptr + key4[key_ptr];

			for (size_t i = 0; i < 3; i++)
			{
				dst[dst_ptr + i] = dst[back_ptr++];
			}

			shift = *reinterpret_cast<const u32*>(&key3[key_ptr * 4]) >> 1;

			offset += shift;

			if (*reinterpret_cast<const u32*>(&key3[key_ptr * 4]) & 1)
			{
				shift += 8;

				data = BitUtils::RotateLeft(data, shift);

				key_ptr = data & 0xFF;
				shift = *reinterpret_cast<const u32*>(&key2[key_ptr * 4]);
				offset += shift;

				const u8 prev_key1 = key1[key_ptr];
				dst[dst_ptr++] += prev_key1;

				data = BitUtils::RotateLeft(data, shift);

				key_ptr = data & 0xFF;
				shift = *reinterpret_cast<const u32*>(&key2[key_ptr * 4]);
				offset += shift;

				dst[dst_ptr++] += prev_key1 + key1[key_ptr];

				data = BitUtils::RotateLeft(data, shift);

				key_ptr = data & 0xFF;
				shift = *reinterpret_cast<const u32*>(&key2[key_ptr * 4]);
				offset += shift;

				dst[dst_ptr++] += prev_key1 + key1[key_ptr];
			}
			else
			{
				dst_ptr += 3;
			}
		}
	}

	return true;
}

/// Decryption
///
/// @param data      Data
/// @param data_size Data size
///
bool CTCDBase::Decrypt(u8* data, size_t data_size)
{
	for (size_t i = 0; i < data_size; i++)
	{
		data[i] = BitUtils::RotateRight(data[i], 1);
	}

	return true;
}

#include "stdafx.h"
#include "../../Image.h"
#include "../../Sound/Ogg.h"
#include "TCDBase.h"

//////////////////////////////////////////////////////////////////////////////////////////
// Mount

BOOL CTCDBase::Mount(
    CArcFile*			pclArc							// Archive
    )
{
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Decode

BOOL CTCDBase::Decode(
    CArcFile*			pclArc							// Archive
    )
{
    SFileInfo* pstFileInfo = pclArc->GetOpenFileInfo();

    if( pstFileInfo->format == _T("TCT") )
    {
        return DecodeTCT( pclArc );
    }

    if( pstFileInfo->format == _T("TSF") )
    {
        return DecodeTSF( pclArc );
    }

    if( pstFileInfo->format == _T("SPD") )
    {
        return DecodeSPD( pclArc );
    }

    if( pstFileInfo->format == _T("OGG") )
    {
        return DecodeOgg( pclArc );
    }

    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Decode TCT

BOOL CTCDBase::DecodeTCT(
    CArcFile*			pclArc							// Archive
    )
{
    // TSF Decoding routine

    return DecodeTSF( pclArc);
}

//////////////////////////////////////////////////////////////////////////////////////////
// Decode TSF

BOOL CTCDBase::DecodeTSF(
    CArcFile*			pclArc							// Archive
    )
{
    SFileInfo* pstFileInfo = pclArc->GetOpenFileInfo();

    // Adjust input buffer
    DWORD dwSrcSize = pstFileInfo->sizeCmp;
    YCMemory<BYTE> clmbtSrc( dwSrcSize );

    // Read
    pclArc->Read( &clmbtSrc[0], dwSrcSize );

    // Ensure output buffer
    DWORD dwDstSize = *(DWORD*)&clmbtSrc[0];
    YCMemory<BYTE> clmbtDst( dwDstSize );

    // Decompress
    DecompLZSS( &clmbtDst[0], dwDstSize, &clmbtSrc[4], (dwSrcSize - 4) );

    // Decode
    Decrypt( &clmbtDst[0], dwDstSize );

    // Output
    pclArc->OpenFile();
    pclArc->WriteFile( &clmbtDst[0], dwDstSize, dwSrcSize );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Decode SPD

BOOL CTCDBase::DecodeSPD(
    CArcFile*			pclArc							// Archive
    )
{
    SFileInfo* pstFileInfo = pclArc->GetOpenFileInfo();

    // Ensure input buffer
    DWORD dwSrcSize = pstFileInfo->sizeCmp;
    YCMemory<BYTE> clmbtSrc( dwSrcSize );

    // Read
    pclArc->Read( &clmbtSrc[0], dwSrcSize );

    // Get header info
    DWORD dwDataSize = *(DWORD*)&clmbtSrc[16];

    long lWidth = *(long*)&clmbtSrc[8] - ((dwDataSize & 0x04DF) << 2);
    long lHeight = *(long*)&clmbtSrc[12] - ((dwDataSize >> 2) & 0xF731);
    WORD wBpp = *(WORD*)&clmbtSrc[6];

    DWORD dwFlags = *(DWORD*)&clmbtSrc[4] - ((dwDataSize << 4) & 0xFFFF);

    // Ensure output buffer
    DWORD dwDstSize = dwDataSize;
    YCMemory<BYTE> clmbtDst( dwDstSize );

    DWORD dwDstSize2 = lWidth * lHeight * 4;
    YCMemory<BYTE> clmbtDst2;

    BYTE* pbtUnLZSSBuffer = &clmbtSrc[0];
    DWORD dwUnLZSSBufferSize = dwSrcSize;

    BYTE* pbtDstForFinal = &clmbtDst[0];
    DWORD dwDstSizeForFinal = dwDstSize;

    // Decompression

    if( (dwFlags & 0xFF00) == 0 )
    {
        DecompLZSS( &clmbtDst[0], dwDstSize, &clmbtSrc[20], (dwSrcSize - 20) );

        // Ensure buffer to perform the following decompression

        clmbtDst2.resize( dwDstSize2 );

        pbtUnLZSSBuffer = &clmbtDst[0];
        dwUnLZSSBufferSize = dwDstSize;

        pbtDstForFinal = &clmbtDst2[0];
        dwDstSizeForFinal = dwDstSize2;
    }

    switch( dwFlags & 0xFFFF )
    {
    case 0: // RLE0
        wBpp = 32;
        DecompRLE0( &pbtDstForFinal[0], dwDstSizeForFinal, &pbtUnLZSSBuffer[0], dwUnLZSSBufferSize );
        break;

    case 1: // No compression
        pbtDstForFinal = pbtUnLZSSBuffer;
        dwDstSizeForFinal = dwUnLZSSBufferSize;
        break;

    case 2: // RLE2
        wBpp = 32;
        DecompRLE2( &pbtDstForFinal[0], dwDstSizeForFinal, &pbtUnLZSSBuffer[0], dwUnLZSSBufferSize );
        break;

    case 257: // Compression Transformation
        DecompSPD( &pbtDstForFinal[0], dwDstSizeForFinal, &pbtUnLZSSBuffer[0], dwUnLZSSBufferSize, lWidth );
        break;

    default: // Unknown
        pclArc->OpenFile();
        pclArc->WriteFile( &clmbtSrc[0], dwSrcSize );
        return TRUE;
    }

    // Output

    CImage clImage;
    clImage.Init( pclArc, lWidth, lHeight, wBpp );
    clImage.WriteReverse( pbtDstForFinal, dwDstSizeForFinal, dwSrcSize );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Decode Ogg Vorbis

BOOL CTCDBase::DecodeOgg(
    CArcFile*			pclArc							// Archive
    )
{
    SFileInfo* pstFileInfo = pclArc->GetOpenFileInfo();

    // Ensure input buffer
    DWORD dwSrcSize = pstFileInfo->sizeCmp;
    YCMemory<BYTE> clmbtSrc( dwSrcSize );

    // Read
    pclArc->Read( &clmbtSrc[0], dwSrcSize );

    // Fix the CRC of Ogg Vorbis on output
    COgg clOgg;
    clOgg.Decode( pclArc, &clmbtSrc[0] );

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Decompress LZSS

BOOL CTCDBase::DecompLZSS(
    void*				pvDst,							// Destination
    DWORD				dwDstSize,						// Destination Size
    const void*			pvSrc,							// Input Data
    DWORD				dwSrcSize						// Input Data Size
    )
{
    BYTE* pbtDst = (BYTE*)pvDst;
    const BYTE* pbtSrc = (const BYTE*)pvSrc;

    DWORD dwSrcPtr = 0;
    DWORD dwDstPtr = 0;

    while( (dwSrcPtr < dwSrcSize) && (dwDstPtr < dwDstSize) )
    {
        BYTE btFlags = pbtSrc[dwSrcPtr++];

        for( DWORD i = 0 ; (i < 8) && (dwSrcPtr < dwSrcSize) && (dwDstPtr < dwDstSize) ; i++ )
        {
            if( btFlags & 1 )
            {
                // No compression

                pbtDst[dwDstPtr++] = pbtSrc[dwSrcPtr++];
            }
            else
            {
                // Is compressed 

                WORD wWork = *(WORD*)&pbtSrc[dwSrcPtr];

                WORD wLength = (wWork & 0x0F) + 3;
                WORD wBack = (wWork >> 4);

                DWORD dwBackPtr = (dwDstPtr - wBack);

                if( (dwDstPtr + wLength) > dwDstSize )
                {
                    wLength = dwDstSize - dwDstPtr;
                }

                for( DWORD j = 0 ; j < wLength ; j++ )
                {
                    pbtDst[dwDstPtr++] = pbtDst[dwBackPtr++];
                }

                dwSrcPtr += 2;
            }

            btFlags >>= 1;
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
//	Decode RLE (Type 0)

BOOL CTCDBase::DecompRLE0(
    void*				pvDst,							// Destination
    DWORD				dwDstSize,						// Destination Size
    const void*			pvSrc,							// Input Data
    DWORD				dwSrcSize						// Input Data Size
    )
{
    const BYTE* pbtSrc = (const BYTE*)pvSrc;
    BYTE* pbtDst = (BYTE*)pvDst;

    DWORD dwOffset = *(DWORD*)&pbtSrc[0];
    DWORD dwPixelCount = *(DWORD*)&pbtSrc[4];
    DWORD dwZeroFlag = *(DWORD*)&pbtSrc[8];

    BOOL bZero = (dwZeroFlag == 0);

    DWORD dwSrcHeaderPtr = 12;
    DWORD dwSrcDataPtr = dwOffset;
    DWORD dwDstPtr = 0;

    while( (dwSrcHeaderPtr < dwOffset) && (dwSrcDataPtr < dwSrcSize) && (dwDstPtr < dwDstSize) )
    {
        DWORD dwLength = *(DWORD*)&pbtSrc[dwSrcHeaderPtr];

        dwSrcHeaderPtr += 4;

        if( (dwDstPtr + (dwLength * 4)) > dwDstSize )
        {
            MessageBox( NULL, _T("Output buffer needed to decompress RLE0 is too small."), _T("Error"), 0 );
        }

        if( bZero )
        {
            for( DWORD i = 0 ; i < dwLength ; i++ )
            {
                for( DWORD j = 0 ; j < 4 ; j++ )
                {
                    pbtDst[dwDstPtr++] = 0x00;
                }
            }
        }
        else
        {
            if( (dwSrcDataPtr + (dwLength * 3)) > dwSrcSize )
            {
                MessageBox( NULL, _T("Input buffer needed to decompress RLE0 is too small."), _T("Error"), 0 );
            }

            for( DWORD i = 0 ; i < dwLength ; i++ )
            {
                for( DWORD j = 0 ; j < 3 ; j++ )
                {
                    pbtDst[dwDstPtr++] = pbtSrc[dwSrcDataPtr++];
                }

                pbtDst[dwDstPtr++] = 0xFF;
            }
        }

        bZero = !bZero;
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Decode RLE (Type 2)

BOOL CTCDBase::DecompRLE2(
    void*				pvDst,							// Destination
    DWORD				dwDstSize,						// Destination
    const void*			pvSrc,							// Input Data
    DWORD				dwSrcSize						// Input Data Size
    )
{
    return FALSE;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Decompress SPD

BOOL CTCDBase::DecompSPD(
    void*				pvDst,							// Destination
    DWORD				dwDstSize,						// Destination Size
    const void*			pvSrc,							// Input Data
    DWORD				dwSrcSize,						// Input Data Size
    long				lWidth							// Image Width
    )
{
    static const BYTE abtKey1[256] = {
        0x10, 0x0F, 0x0E, 0x0D, 0x0C, 0x0B, 0x0A, 0x09, 0xF7, 0xF6, 0xF5, 0xF4, 0xF3, 0xF2, 0xF1, 0xF0,
        0x08, 0x08, 0x07, 0x07, 0x06, 0x06, 0x05, 0x05, 0xFB, 0xFB, 0xFA, 0xFA, 0xF9, 0xF9, 0xF8, 0xF8,
        0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03,
        0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFD, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xFC,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
        0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02, 0x02,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
        0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE,
        0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE, 0xFE
    };

    static const BYTE abtKey2[1024] = {
        0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00, 0x08, 0x00, 0x00, 0x00,
        0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
        0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
        0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
        0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
        0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00
    };

    static const BYTE abtKey3[128] = {
        0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00, 0x04, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00,
        0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00, 0x06, 0x00, 0x00, 0x00,
        0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00, 0x07, 0x00, 0x00, 0x00,
        0x0A, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00, 0x0A, 0x00, 0x00, 0x00, 0x0B, 0x00, 0x00, 0x00,
        0x04, 0x00, 0x00, 0x00, 0x05, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00, 0x02, 0x00, 0x00, 0x00
    };

    long alKey4[28];
    long lWork;

    for( DWORD i = 0 ; i < 16 ; i++ )
    {
        alKey4[i] = -3;
    }

    lWork = ~(lWidth * 3) + 1;

    for( DWORD i = 16 ; i < 24 ; i++ )
    {
        alKey4[i] = lWork;
    }

    for( DWORD i = 24 ; i < 26 ; i++ )
    {
        alKey4[i] = (lWork - 3);
    }

    for( DWORD i = 26 ; i < 28 ; i++ )
    {
        alKey4[i] = (lWork + 3);
    }

    // Decompress

    const BYTE* pbtSrc = (const BYTE*)pvSrc;
    BYTE* pbtDst = (BYTE*)pvDst;

    DWORD dwSrcPtr = 20;
    DWORD dwDstPtr = 0;
    DWORD dwOffset = 24;

    for( DWORD i = 0 ; i < 3 ; i++ )
    {
        pbtDst[dwDstPtr++] = pbtSrc[dwSrcPtr + i];
    }

    while( dwDstPtr < dwDstSize )
    {
        DWORD dwSrcPtrTemp = dwSrcPtr + (dwOffset >> 3);
        DWORD dwShift = (dwOffset & 7);

        DWORD dwData = *(DWORD*)&pbtSrc[dwSrcPtrTemp + 0];
        DWORD dwKeyPtr = *(DWORD*)&pbtSrc[dwSrcPtrTemp + 1];

        _asm
        {
            push  ecx
            push  edx
            push  ebx
            push  esi

            mov   edx, dwData
            mov   esi, dwKeyPtr
            mov   ecx, dwShift
            xor   ebx, ebx

            bswap edx
            shld  edx, esi, cl
            shld  ebx, edx, 5

            mov   dwData, edx
            mov   dwKeyPtr, ebx

            pop   esi
            pop   ebx
            pop   edx
            pop   ecx
        }

        if( dwKeyPtr > 0x1B )
        {
            dwData >>= 5;

            for( DWORD i = 0 ; i < 3 ; i++ )
            {
                pbtDst[dwDstPtr++] = (BYTE)((dwData >> (i * 8)) & 0xFF);
            }

            dwOffset += 0x1B;
        }
        else
        {
            DWORD dwBackPtr = dwDstPtr + alKey4[dwKeyPtr];

            for( DWORD i = 0 ; i < 3 ; i++ )
            {
                pbtDst[dwDstPtr + i] = pbtDst[dwBackPtr++];
            }

            dwShift = *(DWORD*)&abtKey3[dwKeyPtr * 4] >> 1;

            dwOffset += dwShift;

            if( *(DWORD*)&abtKey3[dwKeyPtr * 4] & 1 )
            {
                BYTE btPrevKey1 = 0;

                dwShift += 8;

                _asm
                {
                    push ecx

                    mov  ecx, dwShift
                    rol  dwData, cl

                    pop  ecx
                }

                dwKeyPtr = (dwData & 0xFF);
                dwShift = *(DWORD*)&abtKey2[dwKeyPtr * 4];
                dwOffset += dwShift;

                btPrevKey1 = abtKey1[dwKeyPtr];
                pbtDst[dwDstPtr++] += btPrevKey1;

                _asm
                {
                    push ecx

                    mov  ecx, dwShift
                    rol  dwData, cl

                    pop  ecx
                }

                dwKeyPtr = (dwData & 0xFF);
                dwShift = *(DWORD*)&abtKey2[dwKeyPtr * 4];
                dwOffset += dwShift;

                pbtDst[dwDstPtr++] += btPrevKey1 + abtKey1[dwKeyPtr];

                _asm
                {
                    push ecx

                    mov  ecx, dwShift
                    rol  dwData, cl

                    pop  ecx
                }

                dwKeyPtr = (dwData & 0xFF);
                dwShift = *(DWORD*)&abtKey2[dwKeyPtr * 4];
                dwOffset += dwShift;

                pbtDst[dwDstPtr++] += btPrevKey1 + abtKey1[dwKeyPtr];
            }
            else
            {
                dwDstPtr += 3;
            }
        }
    }

    return TRUE;
}

//////////////////////////////////////////////////////////////////////////////////////////
// Decryption

BOOL CTCDBase::Decrypt(
    void*				pvData,							// Data
    DWORD				dwDataSize						// Data Size
    )
{
    BYTE* pbtData = (BYTE*)pvData;

    for( DWORD i = 0 ; i < dwDataSize ; i++ )
    {
        BYTE btData = pbtData[i];

        _asm
        {
            ror btData, 1
        }

        pbtData[i] = btData;
    }

    return TRUE;
}
